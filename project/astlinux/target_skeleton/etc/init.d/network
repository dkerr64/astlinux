#!/bin/bash

. /etc/rc.conf

. /etc/init.d/functions.d/network
. /etc/init.d/functions.d/misc

# Initialize internal and external interfaces
INTIF_VARS="INTIF"
for i in $(seq 2 ${INTIF_COUNT:-4}); do INTIF_VARS="${INTIF_VARS} INT${i}IF"; done;
INTIF_NAMES=""
for i in $INTIF_VARS; do INTIF_NAMES="${INTIF_NAMES} ${!i/none}"; done
EXTIF_VARS="EXTIF EXT2IF"
EXTIF_NAMES=""
for i in $EXTIF_VARS; do EXTIF_NAMES="${EXTIF_NAMES} ${!i/none}"; done
# Get list of bridge interfaces configured, e.g. "BRIDGE0 BRIDGE1"
BRIDGEIF_VARS=""
for i in $(seq 0 9); do brvar="BRIDGE${i}" && [ -n "${!brvar}" ] && BRIDGEIF_VARS="${BRIDGEIF_VARS} ${brvar}"; done
BRIDGEIF_NAMES=""
for brvar in $BRIDGEIF_VARS; do BRIDGEIF_NAMES="${BRIDGEIF_NAMES} ${!brvar}"; done

gen_nopd_dhcp6c_conf()
{
  local interface="$1"

  echo "# Autogenerated.  Do not edit.
interface $interface {
  send ia-na 11;
  send rapid-commit;
};

id-assoc na 11 { };"

}

gen_dhcp6c_conf()
{
  local interface="$1" dummy=0 len id iname int IFS

  len="${DHCPV6_CLIENT_PREFIX_LEN:-60}"

  # Sanity check the prefix length
  if [ $len -lt 8 -o $len -gt 64 ]; then
    len="60"
  fi

  echo "# Autogenerated.  Do not edit.
interface $interface {"
  if [ "$DHCPV6_CLIENT_REQUEST_ADDRESS" != "no" ]; then
    echo "  send ia-na 1;"
  fi
  if [ "$DHCPV6_CLIENT_REQUEST_PREFIX" != "no" ]; then
    echo "  send ia-pd 1;"
  fi
  echo "  send rapid-commit;"
  echo "  script \"/etc/dhcp6c.script\";"
  echo "};"

  if [ "$DHCPV6_CLIENT_REQUEST_ADDRESS" != "no" ]; then
    echo "
id-assoc na 1 { };"
  fi

  if [ "$DHCPV6_CLIENT_REQUEST_PREFIX" != "no" ]; then
    echo "
id-assoc pd 1 {"
    if [ "$DHCPV6_CLIENT_PREFIX_HINT" != "no" ]; then
      echo "  prefix ::/$len infinity;"
    fi

    id=0
    unset IFS
    for ifvar in $IPV6_PREFIX_DELEGATION; do
      _IF="${!ifvar/none}"   # value of INTxIF
      if [[ $INTIF_VARS =~ $ifvar && -n "$_IF" ]]; then
        # subnet comes back set to a 4 digit hex string, convert to decimal
        id="$(printf '%d' 0x$(get_dhcpv6_subnet $_IF $len))"
        echo "  prefix-interface $_IF {
    sla-id $id;
    sla-len $((64-len));
    ifid 1;
  };"

        # Only assign one interface given only a /64 prefix
        if [ $len -eq 64 ]; then
          break
        fi
      fi
    done

    # When no suitable internal interfaces are defined to receive
    # a prefix delegation, use a dummy interface named "ip6pd"
    if [ $id -eq 0 ]; then
      echo "  prefix-interface ip6pd {
    sla-id 0;
    sla-len $((64-len));
    ifid 1;
  };"
      dummy=1
    fi

    echo "};"
  fi

  return $dummy
}

init_dhcp6c()
{
  local iname="$1" interface="$2"

  if [ "$iname" = "ext2if" ]; then
    sysctl -w net.ipv6.conf.${interface}.accept_ra_defrtr=0 >/dev/null
  else
    sysctl -w net.ipv6.conf.${interface}.accept_ra_defrtr=1 >/dev/null
  fi
  sysctl -w net.ipv6.conf.${interface}.accept_ra=2 >/dev/null

  # Make DUID persistant
  ln -sf /mnt/kd/dhcp6c_duid /var/db/dhcp6c_duid

  if [ "$iname" = "ext2if" ]; then
    gen_nopd_dhcp6c_conf $interface > /etc/wide-dhcpv6/dhcp6c-${interface}.conf
  else
    gen_dhcp6c_conf $interface > /etc/wide-dhcpv6/dhcp6c-${interface}.conf
    if [ $? -eq 1 ]; then
      modprobe dummy numdummies=0
      ip link add name ip6pd type dummy
    fi
  fi
}

ipv6_tunnel()
{
  local action="$1" type local_addr remote_addr endpoint_addr

  type="$(echo $IPV6_TUNNEL | cut -d'~' -f1)"
  remote_addr="$(echo $IPV6_TUNNEL | cut -d'~' -f2)"
  endpoint_addr="$(echo $IPV6_TUNNEL | cut -d'~' -f3)"

  case $action in

    start)
      local_addr="$(find_ip_from_if "$EXTIF")"
      if [ -z "$local_addr" ]; then
        echo "ipv6_tunnel: Can't determine local external IPv4 address" >&2
        return
      elif [ -z "$remote_addr" -o -z "$endpoint_addr" ]; then
        echo "ipv6_tunnel: Empty IPV6_TUNNEL variable field(s)" >&2
        return
      fi
      case $type in
        6in4-static)
          ip tunnel add ip6tun mode sit remote $remote_addr local $local_addr ttl 255
          ip link set dev ip6tun up
          ip -6 addr add $endpoint_addr dev ip6tun
          ip -6 route add ::/0 dev ip6tun metric 1
          ;;
        6to4-relay)
          ip tunnel add ip6tun mode sit remote any local $local_addr ttl 255
          ip link set dev ip6tun up
          ip -6 addr add $endpoint_addr dev ip6tun
          ip -6 route add ::/0 via ::192.88.99.1 dev ip6tun metric 1
          ;;
        *)
          echo "ipv6_tunnel: Tunnel type \"$type\" is not supported." >&2
          ;;
      esac
      ;;

    stop)
      case $type in
        6in4-static|6to4-relay)
          ip -6 route flush dev ip6tun
          ip link set dev ip6tun down
          ip tunnel del ip6tun
          ;;
        *)
          echo "ipv6_tunnel: Tunnel type \"$type\" is not supported." >&2
          ;;
      esac
      ;;

  esac
}

bridge_load_configure()
{
  local br_list="$1" br_name="$2" br IFS

  modprobe bridge

  ## Disable bridge firewalling for intra-bridge traffic
  ## Note: For kernels >= 3.18, not loading br_netfilter avoids filtering.

  ip link add name $br_name type bridge

  unset IFS
  for br in $br_list; do
    ip link set dev $br up
    ip link set dev $br master $br_name
  done
}

bridge_remove()
{
  local br_list="$1" br_name="$2" br IFS

  ip link set dev $br_name down

  unset IFS
  for br in $br_list; do
    ip link set dev $br nomaster
    ip link set dev $br down
  done

  ip link delete $br_name type bridge
}

alias_interface()
{
  local action="$1" interface="$2" alias_list="$3" cnt alias IFS

  case $action in

    add)
      cnt=1
      unset IFS
      for alias in $alias_list; do
        ip addr add $alias/32 dev $interface label ${interface}:${cnt}
        cnt=$((cnt+1))
      done
      ;;

    delete)
      unset IFS
      for alias in $alias_list; do
        ip addr delete $alias/32 dev $interface
      done
      ;;

  esac
}

phyeth_disable_offload()
{
  local eth off off_list="$1" IFS

  logger -s -t network -p kern.info "Disabling \"$off_list\" offload on all configured ethernet interfaces."

  unset IFS
  for eth in $EXTIF_NAMES $PPPOEIF $INTIF_NAMES $DMZIF $BRIDGEIF_NAMES $LXC_BRIDGE0; do
    case $eth in
      eth*)
        for off in $off_list; do
          ethtool -K $eth $off off 2>/dev/null
        done
        ;;
    esac
  done
}

init () {

  mkdir -p /tmp/etc/wide-dhcpv6

  if [ -n "$PHYETH" ]; then
    for i in $PHYETH; do
      INT="$(echo $i | cut -d: -f1)"
      SPEED="$(echo $i | cut -d: -f2)"
      DUP="$(echo $i | cut -d: -f3)"

      echo "Setting ethernet parameters for $INT..."
      ethtool -s "$INT" speed "$SPEED" duplex "$DUP" autoneg off
    done
  fi
}

start () {
  local IF

  # IPv6
  if [ "$IPV6" = "yes" -o -n "$BRIDGEIF_NAMES" -o -n "$LXC_BRIDGE" -o -n "$WIREGUARD_IP" ]; then
    modprobe ipv6
    # Disable IPv6 Autoconf by default
    IFS=$'\n'
    for line in $(sysctl -a 2>/dev/null | cut -d' ' -f1 | \
        grep -e "^net\.ipv6\.conf\..*\.autoconf$" \
             -e "^net\.ipv6\.conf\..*\.accept_ra$"); do
      sysctl -w "$line=0" >/dev/null
    done
    unset IFS
  fi

  if [ "$IPV6" = "yes" ]; then
    # Generate a ULA/48 site prefix
    get_ipv6_site_ula_prefix > /dev/null
  fi

  SYS_gen_etc_hosts > /tmp/etc/hosts

  SYS_gen_etc_ethers > /tmp/etc/ethers

  ip addr add 127.0.0.1/8 dev lo scope host
  ip link set dev lo up

  # if you want to change an interface's MAC address, you must do so
  # before marking it up or joining it to a bridge.
  for ifvar in $EXTIF_VARS; do
    _IF="${!ifvar/none}"       # value of EXTxIF
    eval _MAC="\$${ifvar}MAC"  # value of EXTxIFMAC
    if [ -n "$_IF" -a -n "$_MAC" ]; then
      case "$_IF" in
      br[0-9])
        ;;
      *)
        ip link set dev "$_IF" address $_MAC
        ;;
      esac
    fi
  done

  #VLANS
  if [ -n "$VLANS" ]; then
    for i in $VLANS; do
      IF="$(echo $i | cut -d. -f1)"
      VID="$(echo $i | cut -d. -f2)"
      modprobe 8021q
      ip link add link $IF name $IF.$VID type vlan id $VID
      ip link set dev $IF up
      if [ "$VLANCOS" = "yes" ]; then
        vconfig set_egress_map "$IF.$VID" 0 3 > /dev/null
        vconfig set_egress_map "$IF.$VID" 1 3 > /dev/null
        vconfig set_egress_map "$IF.$VID" 2 1 > /dev/null
        vconfig set_egress_map "$IF.$VID" 3 1 > /dev/null
        vconfig set_egress_map "$IF.$VID" 4 4 > /dev/null
        vconfig set_egress_map "$IF.$VID" 5 5 > /dev/null
        vconfig set_egress_map "$IF.$VID" 6 6 > /dev/null
        vconfig set_egress_map "$IF.$VID" 7 7 > /dev/null
      fi
    done
  fi

  #BRIDGES
  for brvar in $BRIDGEIF_VARS; do
    bridge_load_configure "${!brvar}" "br${brvar:(-1)}"
  done

  if [ -n "$LXC_BRIDGE0" ]; then
    bridge_load_configure "$LXC_BRIDGE0" lxcbr0
  fi

  # and now we retry applying the MAC address if it's a bridge interface.
  if [ -n "$EXTIF" -a -n "$EXTIFMAC" -a "$EXTIF" != "none" ]; then
    case "$EXTIF" in
    br[0-9])
      ip link set dev "$EXTIF" down
      ip link set dev "$EXTIF" address $EXTIFMAC
      ;;
    esac
  fi

  if [ -n "$EXT2IF" -a -n "$EXT2IFMAC" -a "$EXT2IF" != "none" ]; then
    case "$EXT2IF" in
    br[0-9])
      ip link set dev "$EXT2IF" down
      ip link set dev "$EXT2IF" address $EXT2IFMAC
      ;;
    esac
  fi

  if [ -n "$IFMTU" ]; then
    for i in $IFMTU; do
      IF="$(echo $i | cut -d: -f1)"
      MTU="$(echo $i | cut -d: -f2)"
      ip link set dev $IF mtu $MTU
    done
  fi

  if [ -n "$PHYETH_DISABLE_OFFLOAD" ]; then
    phyeth_disable_offload "$PHYETH_DISABLE_OFFLOAD"
  fi

  # Now assign IP addresses to internal interfaces.
  # For IPv4 this is manualy assigned with a netmask.
  # For IPv6 there are three ways to assign an address, all of which
  # may be combined (so multiple addresses on a single interface)
  # 1) Manually assigned,
  # 2) Auto assigned from a site ULA prefix,
  # 3) Auto assigned from DHCPv6 client prefix delegation.
  for ifvar in $INTIF_VARS "DMZIF"; do
    _IF="${!ifvar/none}"           # value of INTxIF (or DMZIF)
    eval _IP="\$${ifvar/IF/IP}"    # value of INTxIP
    eval _NM="\$${ifvar/IF/NM}"    # value of INTxNM
    eval _IP6="\$${ifvar/IF/IPV6}" # value of INTxIPV6
    if [ -n "$_IF" ]; then
      bringup=""
      if [ -n "$_IP" -a -n "$_NM" ]; then
        ip addr add $_IP/$_NM brd + dev $_IF
        if [ "$NTPBROADCAST" = "yes" ]; then
          ip route add 224.0.0.0/4 dev $_IF
        fi
        bringup="yes"
      fi
      if [ "$IPV6" = "yes" ]; then
        IFS=" ,"
        for ipv6_addr in $_IP6; do
          ip -6 addr add $ipv6_addr dev $_IF
          bringup="yes"
        done
        unset IFS
        regex="\b${ifvar}\b"  # Regex so works with commas
        if [[ "$IPV6_PREFIX_ULA" =~ $regex ]]; then
          ip -6 addr add $(get_ipv6_site_ula_prefix $_IF) dev $_IF
          bringup="yes"
        fi
        if [[ "$IPV6_PREFIX_DELEGATION" =~ $regex && "$DHCPV6_CLIENT_REQUEST_PREFIX" != "no" ]]; then
          bringup="yes"
        fi
      fi
      if [ "$bringup" = "yes" ]; then
        ip link set dev $_IF up
      fi
    fi
  done

  if [ -n "$WANDELAY" ]; then
    echo "Sleeping for $WANDELAY seconds before I bring up $EXTIF..."
    sleep $WANDELAY
  fi

  # PPPoE Again!
  if isextppp; then
    case $PPPOEIF in
    eth*)
      ip link set dev $PPPOEIF up ;;
    br[0-9])
      ip link set dev $PPPOEIF up
      # because bridging does weird and unpleasant things to PPPoE packets
      sysctl -w net.bridge.bridge-nf-filter-pppoe-tagged=0 >/dev/null
      ;;
    esac

    /usr/sbin/pppoe-start
    sleep 4

    #end PPPoE
  else
    rm -f /tmp/etc/ppp/pppoe.conf
  fi

  #Static IP Failover Interface
  if [ -n "$EXT2IP" -a -n "$EXT2IF" ] && ! isextppp ext2if; then

    case $EXT2IF in
    wp)
      ;;
    hdlc0|pvc0)
      ip tunnel add $EXT2IF mode ipip remote $EXT2GW local $EXT2IP
      ip link set dev $EXT2IF up
      ;;
    *)
      up_delay=0
      ip addr add $EXT2IP/$EXT2NM brd + dev $EXT2IF
      if [ -n "$EXT2IP_ALIAS" ]; then
        alias_interface add $EXT2IF "$EXT2IP_ALIAS"
      fi
      if [ "$IPV6" = "yes" ]; then
        if [ "$EXT2DHCPV6_CLIENT_ENABLE" = "yes" ]; then
          up_delay=4
          init_dhcp6c ext2if $EXT2IF
          ifplugd -apq -t2 -u3 -d3 -i $EXT2IF -r /etc/ifplugd/dhcp6c.action
        elif [ -n "$EXT2IPV6" ]; then
          ip -6 addr add $EXT2IPV6 dev $EXT2IF
        fi
      fi
      ip link set dev $EXT2IF up
      if [ $up_delay -gt 0 ]; then
        sleep $up_delay
      fi
      ;;
    esac

    if [ -n "$EXT2GW" ]; then
      for x in $EXT2ROUTES; do
        ip route add $x via $EXT2GW dev $EXT2IF
      done
    fi
    if [ "$IPV6" = "yes" -a -n "$EXT2GWIPV6" ]; then
      for x in $EXT2ROUTESIPV6; do
        ip -6 route add $x via $EXT2GWIPV6 dev $EXT2IF metric 1
      done
    fi
    #end static ip on 2nd if
  fi

  #Static IP
  if [ -n "$EXTIP" -a -n "$EXTIF" ] && ! isextppp extif; then

    case $EXTIF in
    wp)
      ;;
    hdlc0|pvc0)
      ip tunnel add $EXTIF mode ipip remote $EXTGW local $EXTIP
      ip link set dev $EXTIF up
      ;;
    *)
      up_delay=0
      ip addr add $EXTIP/$EXTNM brd + dev $EXTIF
      if [ -n "$EXTIP_ALIAS" ]; then
        alias_interface add $EXTIF "$EXTIP_ALIAS"
      fi
      if [ "$IPV6" = "yes" ]; then
        if [ "$DHCPV6_CLIENT_ENABLE" = "yes" ]; then
          up_delay=10
          init_dhcp6c extif $EXTIF
          ifplugd -apq -t2 -u3 -d3 -i $EXTIF -r /etc/ifplugd/dhcp6c.action
        fi
        if [ "$DHCPV6_CLIENT_ENABLE" != "yes" -o "$DHCPV6_CLIENT_REQUEST_ADDRESS" = "no" ]; then
          if [ -n "$EXTIPV6" ]; then
            ip -6 addr add $EXTIPV6 dev $EXTIF
          fi
        fi
      fi
      ip link set dev $EXTIF up
      while [ $up_delay -gt 0 ] && [ ! -f /var/db/dhcp6c_cache ]; do
        up_delay=$((up_delay - 1))
        sleep 1
      done
      ;;
    esac

    if [ -n "$EXTGW" ]; then
      ip route add default via $EXTGW dev $EXTIF
    fi
    if [ "$IPV6" = "yes" ] && [ "$DHCPV6_CLIENT_ENABLE" != "yes" -o "$DHCPV6_CLIENT_REQUEST_ADDRESS" = "no" ]; then
      if [ -n "$EXTIPV6" ]; then
        if [ -n "$EXTGWIPV6" ]; then
          ip -6 route add default via $EXTGWIPV6 dev $EXTIF metric 1
        else
          # Use Router Advertisements to set the default route
          sysctl -w net.ipv6.conf.${EXTIF}.accept_ra_defrtr=1 >/dev/null
          sysctl -w net.ipv6.conf.${EXTIF}.accept_ra=2 >/dev/null

        fi
      fi
    fi
    #end static IP
  fi

  #DHCP Failover Interface
  if [ -n "$EXT2IF" -a -z "$EXT2IP" ] && ! isextppp ext2if; then
    if [ "$IPV6" = "yes" -a "$EXT2DHCPV6_CLIENT_ENABLE" = "yes" ]; then
      init_dhcp6c ext2if $EXT2IF
    fi
    ifplugd -apq -t2 -u3 -d3 -i $EXT2IF -r /etc/ifplugd/udhcpc.action
    ip link set dev $EXT2IF up
    sleep 4

    # No DHCPv6 - Static IPv6 if defined
    if [ "$IPV6" = "yes" ]; then
      if [ -n "$EXT2IPV6" -a "$EXT2DHCPV6_CLIENT_ENABLE" != "yes" ]; then
        ip -6 addr add $EXT2IPV6 dev $EXT2IF
      fi
      if [ -n "$EXT2GWIPV6" ]; then
        for x in $EXT2ROUTESIPV6; do
          ip -6 route add $x via $EXT2GWIPV6 dev $EXT2IF metric 1
        done
      fi
    fi
  fi

  #DHCP
  if [ -n "$EXTIF" -a -z "$EXTIP" ] && ! isextppp extif; then
    up_delay=0
    ip link set dev $EXTIF up
    sleep 4
    if [ "$IPV6" = "yes" -a "$DHCPV6_CLIENT_ENABLE" = "yes" ]; then
      up_delay=10
      init_dhcp6c extif $EXTIF
      dhcp6c -c /etc/wide-dhcpv6/dhcp6c-$EXTIF.conf -p /var/run/dhcp6c-$EXTIF.pid $EXTIF
    fi
    udhcpc -b -T2 -t6 -S -s /etc/udhcpc.script -x "hostname:$HOSTNAME" -p /var/run/udhcpc-$EXTIF.pid -i $EXTIF
    ifplugd -apq -t2 -u3 -d3 -i $EXTIF -r /etc/ifplugd/udhcpc.action
    while [ $up_delay -gt 0 ] && [ ! -f /var/db/dhcp6c_cache ]; do
      up_delay=$((up_delay - 1))
      sleep 1
    done

    # No DHCPv6 - Static IPv6 if defined
    if [ "$IPV6" = "yes" ] && [ "$DHCPV6_CLIENT_ENABLE" != "yes" -o "$DHCPV6_CLIENT_REQUEST_ADDRESS" = "no" ]; then
      if [ -n "$EXTIPV6" ]; then
        ip -6 addr add $EXTIPV6 dev $EXTIF
        if [ -n "$EXTGWIPV6" ]; then
          ip -6 route add default via $EXTGWIPV6 dev $EXTIF metric 1
        else
          # Use Router Advertisements to set the default route
          sysctl -w net.ipv6.conf.${EXTIF}.accept_ra_defrtr=1 >/dev/null
          sysctl -w net.ipv6.conf.${EXTIF}.accept_ra=2 >/dev/null
        fi
      fi
    fi
  fi

  ##IPv6 Tunnel
  if [ "$IPV6" = "yes" -a -n "$IPV6_TUNNEL" ]; then
    ipv6_tunnel start
  fi

  # Now cleanup the file that holds list of IPv6 prefix subnet ids
  # so that it only contains interfaces that actually exist
  cleanup_dhcpv6_subnet_list

  echo "Network UP"
  sleep 1
}

stop () {
  local IF PID

  if [ "$IPV6" = "yes" -a -n "$IPV6_TUNNEL" ]; then
    echo "Bringing down IPv6 tunnel..."
    ipv6_tunnel stop
  fi

  for PID in $(ls -1 /var/run/ifplugd.*.pid 2>/dev/null); do
    echo "Stopping ifplugd..."
    kill $(cat "$PID")
  done

  for PID in $(ls -1 /var/run/dhcp6c-*.pid 2>/dev/null); do
    echo "Stopping dhcp6c..."
    kill $(cat "$PID")
  done

  for PID in $(ls -1 /var/run/udhcpc-*.pid 2>/dev/null); do
    echo "Stopping udhcpc..."
    kill $(cat "$PID")
  done

  #EXTERNAL INTERFACES
  for ifvar in $EXTIF_VARS; do
    _IF="${!ifvar/none}"                     # value of EXTxIF
    eval _IP_ALIAS="\$${ifvar/IF/IP_ALIAS}"  # value of EXTxIP_ALIAS
    if [ -n "$_IF" ]; then
      echo "Bringing down $_IF..."
      if [ -n "$_IP_ALIAS" ]; then
        alias_interface delete $_IF "$_IP_ALIAS"
      fi
      ip link set dev $_IF down
    fi
  done

  #INTERNAL INTERFACES
  for eth in $INTIF_NAMES $DMZIF; do
    echo "Bringing down $eth..."
    ip link set dev $eth down
  done

  #BRIDGES
  for brvar in $BRIDGEIF_VARS; do
    bridge_remove "${!brvar}" "br${brvar:(-1)}"
  done

  if [ -n "$LXC_BRIDGE0" ]; then
    bridge_remove "$LXC_BRIDGE0" lxcbr0
  fi

  #VLANS
  if [ -n "$VLANS" ]; then
    for i in $VLANS; do
      ip link set dev $i down
      ip link delete $i
    done
  fi

  if [ -f /var/run/pppoe.pid ]; then
    /usr/sbin/pppoe-stop
  fi

  echo "Network DOWN"
}

case $1 in

start)
  start
  ;;

stop)
  stop
  ;;

init)
  init
  start
  ;;

restart)
  stop
  sleep 2
  start
  ;;

*)
  echo "Usage: start|stop|restart"
  ;;

esac
